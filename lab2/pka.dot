digraph PKA {
    rankdir=LR;

    // Global start and conjunctive state
    start [shape=point];
    AND [shape=diamond, label="AND"];
    start -> AND;

    // Epsilon-split into two DFAs
    AND -> r0 [label="ε"];
    AND -> t0 [label="ε"];

    // First component: minimal DFA for (aa*bb*ab | c*)*(ba(b | (c | ac)ac | cc(bb | aba))*)*
    subgraph cluster_regex {
        
        node [shape=doublecircle]; r0 r1 r2;
        node [shape=circle];

        r0 -> r11 [label="b"];
        r0 -> r0  [label="c"];
        r0 -> r7  [label="a"];

        r1 -> r2  [label="b"];
        r1 -> r5  [label="c"];
        r1 -> r9  [label="a"];

        r2 -> r2  [label="b"];
        r2 -> r5  [label="c"];
        r2 -> r1  [label="a"];

        r3 -> r11 [label="b"];
        r3 -> r10 [label="c"];
        r3 -> r10 [label="a"];

        r4 -> r13 [label="b"];
        r4 -> r10 [label="c"];
        r4 -> r3  [label="a"];

        r5 -> r10 [label="b"];
        r5 -> r4  [label="c"];
        r5 -> r12 [label="a"];

        r6 -> r6  [label="b"];
        r6 -> r10 [label="c"];
        r6 -> r14 [label="a"];

        r7 -> r6  [label="b"];
        r7 -> r10 [label="c"];
        r7 -> r7  [label="a"];

        r8 -> r10 [label="b"];
        r8 -> r10 [label="c"];
        r8 -> r12 [label="a"];

        r9 -> r10 [label="b"];
        r9 -> r8  [label="c"];
        r9 -> r10 [label="a"];

        // r10 is the dead/sink state
        r10 -> r10 [label="b"];
        r10 -> r10 [label="c"];
        r10 -> r10 [label="a"];

        r11 -> r10 [label="b"];
        r11 -> r10 [label="c"];
        r11 -> r1  [label="a"];

        r12 -> r10 [label="b"];
        r12 -> r1  [label="c"];
        r12 -> r10 [label="a"];

        r13 -> r1  [label="b"];
        r13 -> r10 [label="c"];
        r13 -> r10 [label="a"];

        r14 -> r0  [label="b"];
        r14 -> r10 [label="c"];
        r14 -> r10 [label="a"];
    }

    subgraph cluster_filter {

        node [shape=doublecircle]; t0 t2;
        node [shape=circle];

        // t0: start, accepting, so ε (empty word) allowed; only "b" alone is rejected.
        t0 -> t1 [label="b"];
        t0 -> t2 [label="a"];
        t0 -> t2 [label="c"];

        // t1: we have read exactly "b" so far (non-accepting)
        t1 -> t2 [label="a"];
        t1 -> t2 [label="b"];
        t1 -> t2 [label="c"];

        // t2: any other word (length ≥1 and != "b"), accepting sink
        t2 -> t2 [label="a"];
        t2 -> t2 [label="b"];
        t2 -> t2 [label="c"];
    }
}
